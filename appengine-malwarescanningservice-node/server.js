/*
* Copyright 2019 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const express = require('express');
const uuid = require('uuid');

const fs = require('fs');
const bodyParser = require('body-parser');
const {Storage} = require('@google-cloud/storage');

const app = express();
const PORT = process.env.PORT || 8080;
const scanner = clamd.createScanner('127.0.0.1', 3310);
const CLOUD_STORAGE_BUCKET = process.env.UNSCANNED_BUCKET // 'unscanned-beau-virus'; //process.env.UNSCANNED_BUCKET;
const CLEAN_BUCKET = 'scanned-beau-virus'; //process.env.CLEAN_BUCKET;
const QUARANTINED_BUCKET = 'quarantined-beau-virus'; //process.env.QUARANTINED_BUCKET;

app.use(bodyParser.json());

// Creates a client
const storage = new Storage();

// Get the bucket which is declared as an environment variable
let srcbucket = storage.bucket(CLOUD_STORAGE_BUCKET);

const run = () => app.listen(PORT, () => {
  console.log(`Server started on port ${PORT}`);
})

/**
 * Route that is invoked by a Cloud Function when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * @param {object} req The request payload
 * @param {object} res The HTTP response object
 */
app.get('/scan', async (req, res) => {
  const remoteName = req.body.filename; // FIXME
  // const remoteName = '4ef13ca8-bb92-449b-a918-1af33fa39a81/transactions/documentation/f6e90efb-b2c7-477c-a79d-d5ea2a3881da/2021/07/30/4e6f4753-4581-4edf-a953-6a488b5af37c-38465439.txt'; //req.body.filename;
  const pieces = remoteName.split('.');
  const last = pieces[pieces.length-1];
  const ext = last ? '.' + last : ''; // in case the scanner uses MIME types

  console.log(`SERVER ENV ${process.env}`);
  console.log(`SERVER BUCKET NAME: ${JSON.stringify(CLOUD_STORAGE_BUCKET)}`);
  console.log(`SERVER REQUEST: ${JSON.stringify(req.body)}`);
  console.log(`SERVER FILENAME ${JSON.stringify(remoteName)}`);
  
  const destination = `fakename-${uuid.v4()}` + ext;

  console.log("DEST");
  console.log(destination);

  
  try {
    const options = {
      destination // fakename.txt
      //destination: req.path
    };

    //Downloads the file to docker img

    await storage
      .bucket(CLOUD_STORAGE_BUCKET)
      .file(remoteName)
      .download(options);

    const result = await scanner.scanFile(`${destination}`);
    if (result.indexOf('OK') > -1) {
      // Move document to the bucket that holds clean documents
      console.log("Document was sucessfully scanned");
      await moveProcessedFile(remoteName, true);

      // Log scan outcome for document
      console.log(`Scan status for ${remoteName}: CLEAN`)

      // Respond to API client
      res.json({status: 'clean'});
    } else {
      // Move document to the bucket that holds infected documents
      await moveProcessedFile(remoteName, false);

      // Log scan outcome for document
      console.log(`Scan status for ${remoteName}: INFECTED`)

      // Respond to API client
      res.json({
        message: result,
        status: 'infected'
      });
    }
  } catch(e) {
    exec("ls", (error, stdout, stderr) => {
      if (error) {
          console.log(`error: ${error.message}`);
          return;
      }
      if (stderr) {
          console.log(`stderr: ${stderr}`);
          return;
      }
      console.log(`stdout: ${stdout}`);
    });
    console.error(`Error processing the file ${destination} is the path ${req.path}.`, e)
    res.status(500).json({
      message: `${e.toString()}`,
  //    output: `${stdout}`,
      status: 'error'
    });
  } finally {
    // Delete file from the local directory on the container
    deleteLocalCopy(`${destination}`, destination);
  }
})


const deleteLocalCopy = (loc, filename) => {
  fs.unlink(loc, (err) => {
    if (err) {
      console.error(`Error deleting file ${filename}`);
    } else {
      console.log(`File ${filename} was deleted successfully`);
    }
  })
}

const moveProcessedFile = async (filename, isClean) => {
  const srcfile = srcbucket.file(filename);
  const destinationBucketName = isClean ? `gs://${CLEAN_BUCKET}` : `gs://${QUARANTINED_BUCKET}`;
  const destinationBucket = storage.bucket(destinationBucketName);
  await srcfile.move(destinationBucket);
}

run();